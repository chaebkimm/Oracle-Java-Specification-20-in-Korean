# 제 1장. 서론

자바 프로그래밍 언어는 범용, 병렬처리, 클래스기반, 객체지향 특징을 갖는 언어입니다. 자바는 많은 개발자들이 유창하게 구사할 수 있을 정도로 간단하게 설계했습니다. 자바는 C/C++과 관련이 있지만 다르게 구성되었는데, C/C++의 다양한 측면이 생략되었고 다른 언어의 몇몇 아이디어들이 포함되었습니다. 자바는 연구용 언어가 아닌 실무 언어를 의도해서 설계되었고, 그렇기때문에 영국의 컴퓨터 과학자 찰스 앤터니 리처드 호어 기사가 언어 설계에 관한 그의 고전적인 논문에서 제안했던 바와 마찬가지로 자바는 새롭고 검증되지 않은 기능을 피해서 디자인되었습니다. 

자바 프로그래밍 언어는 강하고 정적인 자료형을 가지고 있습니다. 본 규격서에서는 컴파일할 때 발견될 수 있고 반드시 발견되어야 하는 컴파일 시점의 에러와 프로그램 실행 시점의 에러를 분명하게 구분하고 있습니다. 컴파일하는 과정은 보통 소스 코드를 하드웨어에 독립적인 바이트 코드로 번역하는 것으로 이뤄집니다. 프로그램의 실행은 프로그램에서 쓰이는 클래스들을 메모리에 불러오고 하나의 실행 파일로 링크하는 것, 부가적으로 기계어를 생성하고 프로그램을 최적화하는 것, 그리고 실제 프로그램 실행을 모두 포함합니다.

자바 프로그래밍 언어는 하드웨어 관련 세부 사항에 접근할 수 없다는 측면에서 상대적으로 고급 언어에 속합니다. 자바는 자동 저장 공간 관리를 일반적으로 쓰레기 수집기로 수행하는데, 그 목적은 명시적으로 메모리 해제를 할 때 (C에서 `free`와 C++에서의 `delete`) 생길 수 있는 안전 문제를 피하기 위해서입니다. 높은 성능을 가지게 구현된 쓰레기 수집기는 프로그램이 실행 중 렉 상태에 있는 시간을 제한하여 시스템 프로그램과 실시간 애플리케이션을 서포트합니다. 자바는 어떤 안전하지 않은 구문도 포함하지 않으며, 한 예로 배열의 접근을 인덱스 확인 없이 하는 것이 있습니다, 그 이유는 안전하지 않은 구문은 프로그램이 정해진 방법을 벗어난 행동을 하게 만들기 때문입니다.

자바 프로그래밍 언어는 보통 바이트코드 명령어들로 컴파일되며, 바이트코드의 서식은 *자바 가상머신 규격서 SE 20 에디션*에 정의되어 있습니다.

## 1.1 본 규격서의 구성

제 2장은 자바의 어휘와 문법에 대한 표기법을 상술합니다.

제 3장은 자바 프로그래밍 언어의 어휘들이 갖는 구조를 설명하며, 자바 어휘 구조는 C/C++을 기반으로 합니다. 자바는 유니코드 문자들로 작성됩니다. 자바는 ASCII만 지원하는 컴퓨터에서도 유니코드 문자를 쓰는 것을 지원합니다.

제 4장은 자료형, 값, 변수를 설명합니다. 자료형은 기본형과 참조형으로 나눠집니다.

기본형은 모든 하드웨어와 그 위에 구현된 모든 자바 가상머신에서 동일하게 정의되어 있으며, 2의 보수 정수, IEEE 754 부동 소숫점 숫자, `boolean`형, 유니코드 문자인 `char`형이 있습니다. 기본형은 값을 공유하지 않습니다.

참조형은 배열형, 클래스형, 인터페이스 형입니다. 참조형은 동적으로 생성된 객체로 구현되며, 참조형을 구현하는 객체는 클래스나 배열의 인스턴스 입니다. 다수의 참조형 객체가 각각의 객체에 대해 존재할 수 있습니다. 배열을 포함한 모든 객체는 `Object` 클래스의 메소드를 지원하며, Object 클래스는 클래스 계층 구조의 단일 시조입니다. 자바 기본 지원 클래스 중 하나인 `String`은 유니코드 문자열을 지원합니다. 클래스들은 기본형 값들을 객체 내에 포장하기 위해 존재합니다. 많은 경우에, 포장하고 포장을 푸는 것은 컴파일러에서 자동으로 이뤄집니다 (이 경우 포장하는 것은 박싱이라고 불리고, 포장을 푸는 것은 언박싱이라고 불립니다). 클래스들과 인터페이스들은 지네릭일 수 있으며, 이는 클래스들과 인터페이스들이 참조형 값에 따라 변할 수 있다는 것을 의미합니다. 이런 클래스들과 인터페이스들의 변수화된 자료형은 특정 자료형 인자를로 실행될 수 있습니다.

변수는 자료형이 정해진 저장 공간입니다. 기본형 변수는 해당 기본형의 값을 가지고 있습니다. 클래스형 변수는 null 참조값을 가질 수 있고, 지정된 클래스나 그의 자식 클래스의 인스턴스에 대한 참조값을 가질 수도 있습니다. 배열형 변수는 null 참조값 또는 배열에 대한 참조값을 가질 수 있습니다. 클래스 중 하나인 `Object`형의 변수는 null 참조값을 갖거나 클래스, 배열에 상관없이 어떤 객체의 참조값이든 가질 수 있습니다.

제 5장은 형변환과 숫자의 승격에 대해서 설명합니다. 형변환은 식의 컴파일시점 자료형을 바꾸고, 어떤 때는 값도 바꾸기도 합니다. 형변환은 기본형과 참조형간의 박싱 형변환과 언박싱 형변환을 포함하기도 합니다. 숫자의 승격은 숫자 연산자의 피연산자들의 자료형을 통일시켜서 연산이 가능하게 만들기 위해 쓰입니다. 자바에는 구멍이 없으며, 참조형에 대한 형변환은 실행시 체크되어 자료형 안전성을 보장합니다.

제 6장은 선언, 이름, 이름이 의미를 결정하는 방법 (이름이 어떤 선언을 표시하는지)에 대해 설명합니다. 자바 프로그래밍 언어는 클래스, 인터페이스와 그 멤버들이 꼭 사용 전에 선언되어야 하는 것은 아닙니다. 선언하는 순서는 로컬 변수, 로컬 클래스, 로컬 인터페이스, 클래스나 인터페이스의 필드 초기화자에 있어서만 중요합니다. 소스 코드의 가독성을 높이기 위한 이름 짓는 규칙 중 추천되는 방법을 여기서 소개합니다. 

제 7장은 프로그램의 구조와 어떻게 패키지로 구성되는지를 설명합니다. 패키지의 멤버는 클래스, 인터페이스, 서브패키지입니다. 패키지들과 멤버들은 계층적인 이름을 갖게되며, 인터넷 도메일 이름이 유일한 패키지 이름을 만드느데 사용될 수 있습니다. 컴파일 단위는 주어진 패키지의 클래스와 인터페이스들에 대한 선언이 포함되어 있으며, 다른 패키지의 클래스와 인터페이스들을 import해서 짧은 이름으로 쓸 수 있습니다. 

여러 패키지들을 묶어서 모듈을 만들고, 매우 큰 프로그램을 만드는 구성요소로 쓸 수 있습니다. 모듈의 선언은 어떤 다른 모듈과 패키지들내 클래스와 안터페이스들의 컴파일하고 패키지 내의 코드를 실행하기 위해 필요한지 지정합니다.

자바 프로그래밍 언어는 외부에서 패키지, 클래스, 인터페이스로의 접근을 제한할 수 있게 해줍니다. 패키지의 멤버들은 같은 패키지 내에서만 접근 가능하게 할 수 있고, 같은 모듈 내에서만 접근 가능하게 할 수도 있고, 모든 패키지들에서 접근 가능하게 할 수도 있습니다. 비슷한 제약 조건을 클래스와 인터페이스의 멤버들에도 적용할 수 있습니다.

제 8장은 클래스에 대해서 설명합니다. 클래스의 멤버들은 클래스, 인터페이스, 필드 (변수), 메소드입니다. 클래스 변수들은 클래스당 하나만 존재합니다. 클래스 메소드는 특정 객체를 참조하지 않고 동작합니다. 인스턴스 변수는 클래스 인스턴스인 객체 내에 동적으로 생성됩니다. 인스턴스 메소드는 클래스 인스턴스 상에서 호출되며, 메소드가 실행되는동안 메소드가 호출되는 클래스 인스턴스는 현재 객체인 `this`가 되는 방식으로 자바가 객체 지향 프로그래밍 스타일을 서포트합니다.

클래스는 단일 상속을 지원하며, 단일 상속에서는 모든 클래스가 하나의 부모 클래스를 갖습니다.각 클래스는 부모클래스에게 멤버들을 상속받고, 최종적으로 `Object` 클래스에서 멤버들을 상속받습니다. 클래스형의 변수들은 지정된 클래스의 객체들이나 지정된 클래스의 자식 클래스의 객체들을 참조할 수 있으며, 이를 통해 새로운 클래스들을 기존의 메소드와 더불어 다형성으로 쓸 수 있게 해줍니다.

클래스들은 병렬 프로그래밍을 `synchronized` 메소드를 통해 지원합니다. 메소드들에서 실행 중에 발생할 수 있는 예외를 선언해서 컴파일 시점에 예외 상황이 처리된다는 것을 확인할 수 있습니다. 객체들은 쓰레기 수집기에 의해서 제거되기 전에 실행되는 `finalize` 메소드를 선언할 수 있으며, 이를 통해 객체들이 

단순함을 위해서 자바는 클래스의 구현 전에 "헤더"에서 따로 선언하는 것이나 클래스의 계층 구조에서 분리된 자료형의 계층구조를 쓰지 않습니다.

또다른 제한된 종류의 클래스인 레코드 클래스는 값을 모아둔 단순한 객체를 짧게 표현하는 것을 지원합니다.

제 9장은 인터페이스를 설명합니다. 인터페이스의 멤버는 클래스, 인터페이스, 상수 필드, 메소드입니다. 서로 관련 없는 여러 클래스가 같은 인터페이스를 구현할 수 있습니다. 인터페이스형의 변수는 인터페이스를 구현하는 어떤 객체의 참조값이던지 다 될 수 있습니다.

클래스와 인터페이스는 여러 인터페이스들로부터 상속받을 수 있습니다. 하나 이상의 인터페이스를 구현하는 클래스는 부모클래스와 부모인터페이스 모두로부터 메소드를 상속받을 수 있습니다.

어노테이션은 자바 프로그램에 있는 선언에 적용될 수도 있고, 선언과 식에서 자료형을 어떻게 쓸지도 나타낼 수 있는 메타데이터입니다. 어노테이션의 형태는 인터페이스의 특별한 종류인 어노테이션 인터페이스에 의해서 정의됩니다. 어노테이션은 자바 프로그래밍 언어에서 어떤 방식으로든지 소스코드 자체에 영향을 줄 수 없습니다. 하지만 어노테이션은 다양한 도구들에 유용한 입력을 제공합니다.

제 10장은 배열에 대해 설명합니다. 배열 값에 접근할 때는 인덱스가 배열의 범위 안에 있는지 확인합니다. 배열은 동적으로 생성된 객체이고, `Object`형 변수에 대입될 수 있습니다. 자바에서는 다차원 배열 대신 배열의 배열을 지원합니다. 

제 11장은 예외를 설명하며, 예외는 돌이킬 수 없고, 자바 언어의 논리와 병렬처리 메커니즘에 완전히 통합되어 있습니다. 예외에는 확인된 예외, 실행 시점이 예외, 에러의 세가지 종류가 있습니다. 컴파일러는 확인된 예외가 적절하게 처리되는지를 확실히 하기 위해 메소드나 생성자가 미리 선언한 확인된 예외에 한해서만 예외를 발생시킬 것을 허용합니다. 이렇게 컴파일 시점에서 예외 처리기가 있는지 확인되고, 이는 대규모 프로그래밍에서 유용합니다. 유저가 정의한 예외의 대부분은 확인된 예외입니다. 프로그램 동작 중 자바 가상머신에 의해 발견된 허용되지 않은 연산은 `NullPointerException`과 같은 실행 시점의 예외를 발생시킬 수 있습니다. 자바 가상머신에 의해 발견되는 프로그램의 에러로는 `OutOfMemoryError`가 있습니다. 대부분의 단순한 프로그램은 예외를 처리하지 않습니다.

제 12장은 프로그램을 실행할 때 일어날 수있는 일에 대해 설명합니다. 프로그램은 보통 이진수 형태의 실행파일로 저장이 되며, 실행파일은 컴파일된 클래스와 인터페이스를 나타냅니다. 실행파일은 자바 가상머신에 로드될 수 있고, 다른 클래스 및 인터페이스 정보가 추가되고, 초기화됩니다. 

초기화 후에, 클래스 메소드와 클래스 변수들이 쓰일 수 있습니다. 어떤 클래스들은 인스턴스화되어 해당 클래스 자료형의 새로운 객체를 생성할 수 있습니다. 클래스 인스턴스 객체는 또한 모든 부모 클래스의 인스턴스를 포함하고 있으며, 객체 생성은 재귀적인 부모 클래스 인스턴스의 생성을 포함합니다.

객체가 더이상 참조되지 않으면, 쓰레기 수집기에 의해 회수될 수 있습니다. 객체에 finalizer를 선언되어있으면, 객체가 수집되기 전에 finalize가 실행되어 객체가 쓰레기 수집기에서 처리할 수 없는 리소스들을 반환할 수 있게 해줍니다. 더이상 필요없는 클래스는 언로드될 수 있습니다. 

제 13장은 실행 파일의 호환성에 대해서 설명하고, 클래스와 인터페이스의 실행 파일에 변동이 있을 때 해당 실행 파일을 사용하는 다른 클래스와 인터페이스의 실행 파일에 미칠 수 있는 영향을 명시합니다. 이는 널리 쓰이고 새로운 버전이 인터넷을 통해 계속 공급되는 클래스와 인터페이스의 개발자들이 고려할만한 점입니다. 좋은 프로그램 개발 환경은 클래스와 인터페이스가 바뀔 때마다 이를 사용하는 코드들을 자동으로 새로 컴파일하기 때문에, 대부분의 개발자들은 자세한 내용을 신경쓰지 않아도 괜찮습니다.

제 14장은 블록과 문을 설명하며, 이는 C/C++을 기반으로 하고 있습니다. 자바는 `goto`문이 없지만 대신 라벨링된 `break`와 `continue`문이 있습니다. C와 다르게 자바 프로그래밍 언어는 제어흐름문에서 `boolean` 또는 `Boolean`식을 쓰며, 언박싱을 제외하고는 자료형을 `boolean`형으로 자동 형변화하지 않아서, 에러를 최대한 컴파일 시점에 발견할 수 있도록 했습니다. `synchronized`문를 통해 기본적인 객체 수준의 모니터 락을 제공합니다. `try` 문은 `catch`문과 `finally` 블록을 포함하여 로컬을 벗어나는 프로그램 실행 흐름 이동으로부터 보호할 수 있습니다. 제 14장에서는 또한 패턴을 설명하며, 패턴은 문과 식에서 조건부로 선언하거나 초기화를 할 수 있습니다. 

제 15장은 식을 설명합니다. 여기서는 식의 모든 연산 우선순위를 명확하게 상술하여 결정론성과 이식성을 증가시킵니다. 오버로드된 메소드와 생성자는 컴파일 시점에 어떤 메소드 또는 생성자를 쓸지 정해지며, 정하는 방법은 적용가능한 메소드 또는 생성자 중에서 가장 구체적인 메소드 또는 생성자를 선택하는 것입니다.

제 16장은 자바가 어떻게 로컬 변수가 사용 전에 설정되었는지 보장하는 정확한 방법을 설명합니다. 다른 모든 변수들은 자동으로 기본값으로 초기화되지만, 자바 프로그래밍 언어는 로컬 변수를 초기화하지 않으며, 그 이유는 프로그래밍 오류를 가리지 않기 위해서입니다.

제 17장은 쓰레드와 락의 의미를 설명하며, 쓰레드와 락은 동시대의 Mesa 프로그래밍 언어의 모니터 기반 병렬처리를 기반으로 합니다. 자바 프로그래밍 언어는 멀티쓰레드의 공유메모리 모델을 명시하여 고성능 프로그래밍을 서포트합니다.

제 18장은 다양한 자료형 추론 알고리즘을 소개하며, 자료형 추론은 지네릭 메소드를 적요할 수 있는지 테스트하고 지네릭 메소드 호출시 자료형을 추론하기 위해서 쓰입니다.

제 19장은 자바의 언어 구문을 소개합니다.

## 1.2 프로그램 예제

본 규격서에서 주어지는 대부분의 프로그램 예제는 바로 실행시킬 수 있으며, 아래와 비슷한 형태입니다.
``` java
class Test{
  public static void main (String[] args) {
    for (int i = 0; i < args.length; i++)
      System.out.print(i == 0 ? args[i] : " " + args[i]);
    System.out.println();
  }
}
```
오라클 JDK가 설치된 컴퓨터에서, 위 코드를 Test.java에 저장하면, Test 클래스를 아래와 같은 명령어로 컴파일하고 실행할 수 있습니다.
```
javac Test.java
java Test Hello, world.
```
실행 결과 아래와 같은 출력을 얻습니다.
```
Hello, world.
```




























































































